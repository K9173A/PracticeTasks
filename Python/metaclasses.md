## Метаклассы
Метакласс - это объект, позволяющий определять дополнительную логику на стадии инициализации объекта, который реализует
данный метакласс. Иными словами, метакласс - это фабрика классов.

### Метакласс в жизненном цикле объекта
Цикл состоит из следующих этапов:

* **Подготовка** - стадия подготовки данных класса.
* **Создание** - стадия создания класса.
* **Инициализация** - стадия инициализации класса.
* **Фабрика** - стадия инициализации экземпляра.

Функцию `type()` можно считать базовой фабрикой.

### Пример выполнения
```python
def print_info(*args):
    print('\n', args[0])
    for arg in args[1:]:
        if isinstance(arg, dict):
            print(' ' * 2, '{')
            for k, v in arg.items():
                print(' ' * 4, k, v)
            print(' ' * 2, '}')
        else:
            print(' ' * 2, arg)


class MyMeta(type):
    @classmethod
    def __prepare__(mcs, name, bases):
        print_info('__prepare__()', mcs, name, bases)
        return {'foo': 42}

    def __new__(mcs, clsname, bases, clsdict):
        print_info('__new__()', mcs, clsname, bases, clsdict)
        return type.__new__(mcs, clsname, bases, clsdict)

    def __init__(cls, clsname, bases, clsdict):
        print_info('__init__()', cls, clsname, bases, clsdict)
        super(MyMeta, cls).__init__(clsname, bases, clsdict)

    def __call__(cls, *args, **kwargs):
        print_info('__call__()', cls, args, kwargs)
        return super().__call__(*args, **kwargs)


class Bar:
    pass


class Sample(Bar, metaclass=MyMeta):
    connection_string = 'db.sqlite3'
    table_name = 'Sample'

    def __init__(self, *args, **kwargs):
        super(Sample, self).__init__()
        print_info('__init__() of object', args, kwargs)


s = Sample(2, 3)
print(Sample.foo)
```

### Порядок выполнения
* Интерпретатор на строчке `metaclass=MyMeta` переходит к метаклассу.

#### Стадия подготовки класса
* В метаклассе он ищем метод `__prepare__()`, который должен подготовить окружение класса. Окружение класса являются
статические переменные, doc-строки класса и т.п. Всё то, что потом будут видеть и воспринимать объекты данного класса.
* Метод `__prepare__()` ОБЯЗАН вернуть `dict` или объект, подобный `dict`. В котором будут определены заранее
заготовленные атрибуты, чтобы внедрить их в будущий класс на этапе `__new__()`. Если метод не найден, то используется
дефолтный вариант - пустое окружение (контекст), то есть пустой `dict()`. В нашем варианте будет возвращён словарь
`{'foo': 42}`, а также в консоль будет выведено следующее.
```bash
 __prepare__()
   <class '__main__.MyMeta'> # (mcs) Название текущего метакласса (аналог self)
   Sample # (clsname) Название класса, у которого метаклассом является данный
   (<class '__main__.Bar'>,) # (bases) Список классов-родителей класса <clsname>
```

#### Стадия создания класса
* Далее вызывается метод `__new__()`, который "аллоцирует память" под данный класс (ибо класс тоже является объектом,
который нужно хранить). Но мы сами не пишем аллокатор, а вызываем метод суперкласса `type.__new__()`, который вернёт нам
объект метакласса `mcs`, то есть объект `MyMeta`. Основное назначение переопределения `__new__()` - это кастомизация
создания класса.
* Если `__new__()` вернул новый объект, то вызывается `__init__()`. В нашем варианте в консоль будет выведено:
```bash
 __new__()
   <class '__main__.MyMeta'> # (mcs) Название текущего метакласса (аналог self)
   Sample # (clsname) Название класса, у которого метаклассом является данный
   (<class '__main__.Bar'>,) # (bases) Список классов-родителей класса <clsname>
   { # (clsdict) Cловарь с окружением класса
     foo 42 # То, что мы получили из __prepare__()
     __module__ __main__ # Запускали из текущего модуля, поэтому __main__
     __qualname__ Sample # Название создаваемого класса
     connection_string db.sqlite3 # Первый атрибут в Sample
     table_name Sample # Второй атрибут в Sample
     __init__ <function Sample.__init__ at 0x7f700d3f2730>
     __classcell__ <cell at 0x7f700d451f18: empty>
   }
```

#### Стадия инициализации класса
* Далее вызывается метод `__init__()`, который инеициализирует класс `Sample` (класс - тоже объект). То есть здесь
происходит непосредственная инициализации внутреннего пространства класса - его статических переменных.
* Логично, что раз мы унаследовани метакласс `Meta` от `type`, то в `__init__()` придётся вызывать конструктор
суперкласса `super(Meta, cls).__init__(clsname, bases, clsdict)`.
* В консоль будет выведено всё тоже самое, за исключением первого атрибута - теперь это класс `Sample`.
```bash
 __init__()
   <class '__main__.Sample'> # (cls) ВНИМАНИЕ - здесь уже класс Sample, а не метакласс
   Sample # (clsname) 
   (<class '__main__.Bar'>,) # (bases)
   { # (clsdict)
     foo 42
     __module__ __main__
     __qualname__ Sample
     connection_string db.sqlite3
     table_name Sample
     __init__ <function Sample.__init__ at 0x7f700d3f2730>
     __classcell__ <cell at 0x7f700d451f18: MyMeta object at 0x15aed58>
   }
```

#### Работа с классом
* Далее уже идёт работа с классом `Sample` и его объектами.
```python
s = Sample(2, 3)
```
* Вначале будет вызван `Meta.__call__()`, который создаст объект класса `Sample`. Также в `__call__()` можно
проанализировать переданные аргументы и выкинуть, например, исключение, если пользователь ошибся в чём либо.
```
 __call__()
   <class '__main__.Sample'>
   (2, 3)
   {}
```
* Потом данный объект будет передан в `Sample.__init__()` для инициализации.
```
 __init__() of object
   (2, 3)
   {}
```
* Далее мы обращаемся к статическому атрибуту `print(Sample.foo)`, который должен был нам достаться от метакласса и получаем результат,
как и ожидалось:
```
42
```

