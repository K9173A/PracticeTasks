## `__slots__`
### Введение
По умолчанию классы в Python используют `dict` для хранения атрибутов объекта. У данного способо хранения есть как плюсы,
так и минусы. За счёт того, что `dict` является мутабельной структурой, можно добавлять и удалять атрибуты в рантайм.
Однако эта опция не всегда необходима: в некоторых случаях у нас должны быть объекты с заранее определёнными атрибутами,
и ничего дополнительно добавляться и удаляться не планируется. Также `dict` является дорогим по памяти, так как
использует heap для хранения данных, а также имеет множество втутренних атрибутов для работы с данными (в силу своей
мутабеольности). К частью, механизм `__slots__` позволяет решить некоторые из этих вопросов.

### Основное назначение `__slots__`
Использование `__slots__` позволяет явно указать, какие атрибуты мы ожидаем увидеть в объекте. При этом ожидается
результат:

* Более быстрый доступ к атрибутам -  но это можно гарантировать не в 100% случаев.
* Экономия памяти.

### Реализация `__slots__`
`__slots__` полностью реализован на C: когда `__slots__` используется атрибуты хранятся напрямую в `struct`, который
находится внутри класса. Класс при этом хранит единственную копию таблицы поиска со связкой
`Имя <=> Офсет структуры для каждого атрибута`. C помощью `__slots__` мы экономим 16 байтов на указателях, указывающих
на атрибуты `__dict__` и `__weakref__` - эти атрибуты не создаются, поэтому указывать становится не на что.

### Более быстрый доступ к атрибутам
Guido van Rossum заявлял, что он создавал `__slots__` для более быстрого доступа к атрибутам. Можно показать, что это
так:
```python
import timeit

class Foo:
    __slots__ = ('baz',)

class Bar:
    pass

def manipulate(obj):
    def get_set_del():
        obj.baz = 'baz' # setter
        obj.baz # getter
        del obj.baz # deleter
    return get_set_del

foo = Foo()
bar = Bar()

print(min(timeit.repeat(manipulate(foo)))) # 0.3228757190008764
print(min(timeit.repeat(manipulate(bar)))) # 0.3527928399998927
```
Таким образом мы получили 8.5% прирост в скорости:
```python
print(100 - 0.3228757190008764 / 0.35279283999989275 * 100) # 8.480081681653587
```

### Экономия памяти
Ещё одной целью `__slots__` является сокращение количество выделяемой памяти под каждый объект класса. Атрибуты
SQLAlchemy за счёт `__slots__` сохранили болбшое количество памяти.

У Python имеется механизм ленивой инициализации, который подразумевает, что объект не создаётся до тех пор, пока на него
не сошлются. Поэтому в пустом классе без атрибутов `__dict__` не будет создан, пока мы не будем использовать объекты
класса и что-то делать с атрибутами. Когда `__dict__` создаётся, он занимает минимум 280 байтов. Для разницы, объект
класса со `__slots__`, объявленный пустым `()` занимает только 16 байтов, 56 байтов с одним атрибутом, 64 байта с двумя.

Потребление памяти в байтах в Python 2.7 и Python 3.6 для случаев со `__slots__` и случаев с `__dict__`.

| attrs | `__slots__` (2.7) | `__dict__` (2.7) | `__slots__` (3.6) | `__dict__` (3.6) |
|:--:|:--:|:--:|:--:|:--:|
| 0 | 16 | 56 + 272 | 16 | 56 + 112 |
| 1 | 48 | 56 + 272 | 48 | 56 + 112 |
| 2 | 56 | 56 + 272 | 56 | 56 + 112 |
| 6 | 88 | 56 + 1040 | 88 | 56 + 152 |
| 11 | 128 | 56 + 1040 | 128 | 56 + 240 |
| 22 | 216 | 56 + 3344 | 216 | 56 + 408 |
| 43 | 384 | 56 + 3344 | 384 | 56 + 752 |

### Использование `__slots__`
Чтобы запретить создание `__dict__` в классе:
```python
class Foo:
    __slots__ = ()

foo = Foo()
foo.a = 42 # AttributeError: 'Foo' object has no attribute 'a'
```
Можно унаследовать класс со `__slots__`:
```python
class Child(Foo):
    __slots__ = ('a',)

child = Child()
child.a = 42 # OK
child.b = 42 # AttributeError: 'Child' object has no attribute 'b'
```
Чтобы разрешить создание `__dict__` в классе, который унаследован от класса со `__slots__`, нужно добавить `__dict__` в
`__slots__` (стоит отметить, что у слотов есть последовательность, поэтому не надо повторять слоты, которые уже имеются
в классах-родителях):
```python
class Slotted(Child):
    __slots__ = ('__dict__', 'b')

slotted = Slotted()
slotted.a = 42 # OK
slotted.b = 42 # OK
slotted.c = 42 # OK, т.к. имеется __dict__
print(slotted.__dict__) # {'c': 42}
```
Вам даже не нужно объявлять `__slots__` в дочернем классе, вы всё равно будете использовать слоты ищ родительских классов,
но не ограничивает создание `__dict__`:
````python
class NoSlots(Child):
    pass

no_slots = NoSlots()
no_slots.a = 42 # OK
no_slots.b = 42 # OK
print(no_slots.__dict__) # {'b': 42}
````
Однако слоты могут вызвать проблемы при множественном наследовании:
```python
class BaseA:
    __slots__ = ('a',)

class BaseB:
    __slots__ = ('b',)

# TypeError: Error when calling the metaclass bases
# multiple bases has instance lay-out conflict
class Child(BaseA, BaseB):
    __slots__ = ()
```
Если вы сталкнулись с такой проблемой, можно просто удалить `__slots__` из родительских, или если требуется контроль
родительских классов, задайте в них пустые слоты или отрефакторите в абстракции:
```python
from abc import ABC

class AbstractA(ABC):
    __slots__ = ()

class BaseA(AbstractA): 
    __slots__ = ('a',)

class AbstractB(ABC):
    __slots__ = ()

class BaseB(AbstractB): 
    __slots__ = ('b',)

class Child(AbstractA, AbstractB): 
    __slots__ = ('a', 'b')

c = Child() # OK
```
### Добавление `__dict__` в `__slots__` для установление значений в рантайм
```python
class Foo:
    __slots__ = ('bar', '__dict__')

foo = Foo()
foo.baz = 'baz'
```
С `__dict__` в `__slots__` мы теряем преимущества по памяти, но получаем динамическое установление значений и всё ещё
имеем слоты для имён, которые мы ожидаем.

Если вы наследуетесь от объекта, которые не имеет слотов, вы получаете аналогичную семантику, когда вы используете
`__slots__` - имена, которые находятся в `__slots__` указывают на слотируемые значения, в то время как другие значения
помещаются в инстанс `__dict__`.

Избегание `__slots__`, потому что вы хотите добавлять атрибуты на лету на не является хорошей причиной - 
просто добавьте `__dict__` в ваши `__slots__`, если требуется. Аналогичным образом можно добавить `__weakref__` в 
`__slots__` явно, если требуется эта фича.

### Пустой `tuple`, когда наследуемся от `collections.namedtuple`
`collections.namedtuple` делает инстанс неизменяемым, которые являются легковесными (из-за размера `tuple`).
```python
from collections import namedtuple

class MyNamedTuple(namedtuple('MyNamedTuple', 'bar baz')):
    __slots__ = ()

named_tuple = MyNamedTuple('bar', 'baz')
print(named_tuple.bar) # 'bar'
print(named_tuple.baz) # 'baz'
named_tuple.my_var = 42 # AttributeError: 'MyNamedTuple' object has no attribute 'my_var'
```
Попытка присвоения атрибута выведет `AttributeError`, потому что мы предотвращаем создание `__dict__`. Вы можете
разрешить создание `__dict__`, оставив `__slots__ = ()`, но вы не сможете использовать непустой слот с подтипом `tuple`.

### Множественное наследование и `__slots__`
Даже при непустых слотах с одинаковыми значениями, они не могут быть использованы вместе:
```python
class Foo:
    __slots__ = ('foo', 'bar',)

class Bar:
    __slots__ = ('foo', 'bar',)

# TypeError: Error when calling the metaclass bases
# multiple bases have instance lay-out conflict
class Baz(Foo, Bar):
    pass
```
Использование пустых `__slots__` в родительских классах кажется наиболее гибким решением, позволяющее дочерним классам
выбирать разрешать или запрещать создание `__dict__`:
```python
class Foo:
    __slots__ = ()

class Bar:
    __slots__ = ()

class Baz(Foo, Bar):
    __slots__ = ('foo', 'bar',)

baz = Baz()
baz.foo = 'foo'
baz.bar = 'bar'
``` 
Вы не обязаны иметь слоты - если вы добавили их и удалили позже, это не должно вызывать никаких проблем.

Если вы составляете mixin'ы или используете абстрактные базовые классы, которые не рассчитаны на истанцирование, то
пустой `__slots__` в этих родительских классах является лучшим решением с точки зрения гибкости и подклассов.
```python
class AbstractBase:
    __slots__ = ()

    def __init__(self, a, b):
        self.a = a
        self.b = b
```
Код выше мы могли бы использовать напряму унаследовав и объявив слоты:
```python
class Foo(AbstractBase):
    __slots__ = ('a', 'b',)
```
Но нас не волнует это, это тривиальное наследование, нам нужен ещё один класс, от которого мы сможем унаследоваться:
```python
class AbstractBaseC:
    __slots__ = ()
    
    @property
    def c(self):
        return self._c
    
    @c.setter
    def c(self, arg):
        self._c = arg
```
Если бы оба базовых класса имели бы непустые слоты, мы не могли бы сделать то, что приведено ниже.
```python
class Concretion(AbstractBase, AbstractBaseC):
    __slots__ = 'a b _c'.split()
```
И теперь у насть функционал обоих классов за счёт множественного наследования, и по прежнему запрещает `__dict__` и
`__weakref__` инстанцирование:
```python
concretion = Concretion('a', 'b')
concretion.c = 'c' # OK
print(concretion.c) # OK
concretion.d = 'd' # AttributeError: 'Concretion' object has no attribute 'd'
```
### В какиз случаях нужно избегаит `__slots__`
* Избегайте их, когда вы хотите выполять присвоение `__class__`'а другому классу, который не имеет их (и вы не можете их
добавить) пока структура слотов не является идентичной.
* Избегайте их, если вы хотите унаследовать длину встроенных типов (`str`, `tuple`) и вы хотите добавить в
низ атрибутов.
* Избегайте их, если вы настаиваете на предоставлении значений по умолчанию через атрибуты классов для переменных
объекта.
