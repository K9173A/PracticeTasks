# Big O
Математическое обозначение для сравнения асимптотического поведения функций. Big O показывает верхнюю границу зависимости между входными параметрами функции и количеством операций, которые выполнит процессор.

* Передача файлов по сети: `O(N)`. Больше байт - больше передавать.
* Перенос носителя на самолёте: `O(1)`.
* Размер файла не важен - скорость самолёта не изменится.

`1` - символизация, что что-то происходит. Вызов функции мы в любом случае делаем, поэтому не 0, а 1.

### Пример 1
```java
int sum(int n) {
    if (n == 1) {
        return 1;
    }
    return n + sum(n - 1);
}
```
Какая зависимость значения n и количества раз, которое функция вызвается?

* Если `n = 10` => `10` раз.
* Если `n = 100` => `100` раз.

### Пример 2
```java
int pairSumSequence(int n) {
    int sum = 0;
    for (int i =0; i < n; i++) {
        sum += pairSum(i, i + 1);
	}
    return sum;
}

int pairSum(int a, int b) {
    return a + b;
}
```
Оценка:

* `pairSum()` - `O(1)`, т.к. выполняет константое количество операций (рекурсий и циклов там нет).
* `pairSumSequence()` - `O(N)`. Складывает какие-то числа в цикле, цикл выполняется от `0` до `n`, другими словами, чем больше `n`, тем больше раз выполнится цикл. Если `n = 10` => `10` раз. Если `n = 100` => `100` раз.

## Отбрасывание констант

* Верхняя граница = отбрасывание констант.
* Какое число повторений достаточно? Нужна бесконечность - это обобщение.
* Big O - описывает только скорость роста, поэтому мы отбрасываем константы только при оценке сложности.
* Поэтому алгоритм, описываемый как `O(2N)` должен описываться как `O(N)`.

## Какой код быстрее?
Первый:
```java
int min = Integer.MAX_VALUE;
int max = Integer.MIN_VALUE;
for (int x : array) {
    if (x < min) min = x;
    if (x > max) max = x;
}
```
Второй:
```java
int min = Integer.MAX_VALUE;
int max = Integer.MIN_VALUE;
for (int x : array) {
    if (x < min) min = x;
}
for (int x : array) {
    if (x > max) max = x;
}
```
Ответ:

* Они одинаковы с точки зрения Big O - для обоих случаев это `O(N)`.
* Если посмотреть команды процессора, то второй пример медленнее.

## Неважная сложность
### Как быть со сложностью `O(N^2 + N)`?

* `N` не является константой.
* `O(N^2 + N^2) = O(N^2)`.
* `N^2 >> N` (значительно больше - больше в 2 раза), а значит темп роста `N` почти не влияет на рост функции - основное делает `N^2`.
* Следовательно: `O(N^2 + N) = O(N^2)`.

### Примеры отбрасывания неважной сложности

* `O(N^2 + N^2) = O(N^2)`.
* `O(N^2 + log N) = O(N^2)`.
* `O(5 * 2^N + 10 * N^100) = O(2^N)` - так как степенная функция растёт быстрее.
* `O(N^2 + B)= O(N^2 + B)` - выражение не может быть упрощено, так как мы ничего не знаем о `B`.

## Сложение и умножение
```java
for (int a : arrA) { print(a); }
for (int b : arrB) { print(b); }
```
Сложность O(A + B), так как оба цикла не зависят друг от друга.
```
for (int a : arrA) {
    for (int b : arrB) {
        print(a + "," + b);
    }
}
```
Сложность `O(A * B)`, так как выполняется что-то `N` раз, пока делается что-то своё (вложенность циклов).

## Откуда берётся log N?
Бинарный поиск:

* `2^k = N`
* `k = log_2 N`
* `O(k) = O(log_2 N)`
* Основание логарифма не играет роли, так как константа, поэтому: `O(k) = O(log N)`.
* **Вывод:** для каждого алгоритма, где на каждой итерации берётся половина элементов - сложность будет включать `O(log N)`.

```java
void printPairs(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        for (int j = i; j < arr.length; j++) {
            println(arr[i] + "," + arr[j]);
        }
    }
}
```

* Код внешнего цикла выполнится `N` раз.
* Так как `j = i`, то код внутреннего цикла выполнится: `N, N - 1, N - 2, ..., 2, 1` раз.
* Тогда сложность алгоритма можно описать так: `O(N + (N - 1) + (N - 2) + ... + 2 + 1) = O(N^2 / 2) = O(N^2)`.

## Примеры
### Пример 1
Исходный код:
```java
void printPairs(int[] arrA, int[] arrB) {
    for (int i = 0; i < arrA.length; i++) {
        for (int j =0; j < arrB.length; j++) {
            for (int k = 0; k < 10000; k++) {
                println("Hello world!");
            }
        }
    }
}
```
Псевдокод:
```java
void printPairs(arrA, arrB) {
    for // A раз
        for // B раз
            for // Константное число раз
}
```

* Цикл по `k` делает `10000` операций, следовательно он является константой и не учитывается.
* Циклы по `i` и `j` выполняются `A` и `B` раз соответственно.
* Цикл по `j` расположен внутри цикла по `i`, следовательно, сложность будет равна: `O(A * B)`.

### Пример 2
Функция сортирует строки в массиве строк, а затем сортирует массив. Исходный код:
```java
void sortStr(string[] arr) {
    for (int i = 0; i < arr.length; i++) {
        arr[i] = sortString(arr[i]);
    }
    sortArr(arr);
}
```
Псевдо код:
```java
void sortStr(arr) {
    for { // N раз
        sortString() // L * log L раз
    }
    sortArr() // L * N * log N раз, так как сравнивают строки длинной L
}
```

* Общая сложность будет равна:
```
O(N * L * log L + L * N * log N) = O(L * N * (log L + log N))
```

### Пример 3
Исходный код:
```java
void reverse(int[] arr) {
    for (int i =0; i < arr.length / 2; i++) {
        int other = arr.length - i - 1;
        int temp = arr[i];
        arr[i] = arr[other];
        arr[other] = temp;
    }
}
```
Псевдо код:
```java
void reverse(arr) {
    for // N / 2 раз
}
```

* Цикл выполняется `N / 2` раз, следовательно сложность будет равна: `O(N / 2) = O(N)`.

## Выводы

1. Big O показывает тем роста функции. Следовательно мы не учитываем константы и неважную сложность.
2. Последовательность действий - сложение. Вложенные действия - умножения.
3. Для алгоритма, где на каждой итерации берётся половина элементов - сложность будет включать `O(log N)`.