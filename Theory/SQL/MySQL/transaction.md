## Транзакции
Транзакция - некоторая последовательность действий в БД, которая заканчивается commit'ом, либо rollback'ом. 
Документируется всё на журнале транзакций.

* `SELECT`
* `DELETE`
* `UPDATE`
* `INSERT`

Транзакции поддерживаются только в движке InnoDB.

### Приципы работы с транзакциями (ACID)
#### Atomicity (Атомарность)
Ни одна транзакция не может быть выполнена только в своей части - либо выполняется всё полностью, либо ничего и
откатывается rollback'ом.

#### Isolation (Изоляция)
Параллельные транзакции не влияют на работоспособность друг друга:

* Уровни блокировки
* Уровни изолированности

#### Consistency (Консистентность)
Транзакция фиксирует результат своей работы. При откате фиксируется изначальное состояние, которое было к моменту
запуска транзакции. При успешном выполнении фиксируется новое работоспособносе состояние БД.

#### Durability (Долговечность)
После восстановления системы все успешные транзакции будут сохранены.

### Уровни изоляции
#### 0 - READ UNCOMMITTED, DIRTY READ
Чтение своих и чужих незаконченных транзакций возможна, при этом не гарантируется, что те изменения, которые у остальных
транзакций происходит, могут быть извлечены и тут же. Может приводить к ошибкам.

#### 1 - READ COMMITTED
Транзакция завершилась успешно, можем считать эти данные, а если неуспешно - то не можем.
Самый используемый уровень изоляции - менее затратен, но по результативности может выдать больше.

#### 2 - REPEATABLE READ, SNAPSHOT
Чтение всех изменений, но только внутри своей транзакции. Изменение в других транзакциях не влиет на текущую транзакцию.

#### 3 - SERIALIZABLE
Сериализуемые транзакции, которые являются результатом выполнения сериализуемых транзакуицй с другими транзакциями.
Текущеий результат должен быть идентичен результату параллельного выполнения транзакции. Самый отказоустойчивый уровень
изоляции, но самый ресурсоёмкий.

### Примеры транзакции
#### Пример №1
```mysql
SET autocommit = 0;

BEGIN;

SELECT * FROM salaries;

UPDATE salaries 
   SET salary = salary + 5000
 WHERE salary < 45000
   AND emp_no > 10001
   AND emp_no < 10100;

COMMIT;
```

#### Пример №2
```mysql
SET autocommit = 0;

BEGIN;

SELECT @newClientId:= MAX(emp_no) + 1
  FROM employees;

INSERT INTO employees(emp_no, birth_date, first_name, last_name, gender, hire_date)
	 VALUES (@newClientId, '1991-09-09', 'John', 'Brown', 'M', CURDATE());

COMMIT;
```

### Deadlock
* Пользователь 1:
```mysql
USE employees;
SHOW TABLES;
```
* Пользователь 2:
```mysql
USE employees;
LOCK TABLE employees READ;
```
* Пользователь 1:
```mysql
SELECT *
  FROM employees;
```
* Пользователь 2:
```mysql
INSERT INTO employees
      VALUE (99999, '2013-03-14', 'Maximov', 'Maxim', 'M' '2018-02-16');
```

1. Первая транзакция создаёт блокировку на чтение (read lock).
2. Вторая транзакция хочет получить эксклюзивный доступ и ждёт, пока первая транзакция снимет блокировку (exclusive lock).
3. И та, и другая транзакция хотят получить доступ, но первая уже работает, вторая подала запрос, но не может его
получить его из-за read lock. А первая запрашивает ещё права, но получить их не может, так как права ещё не делегированы
второй транзакцией.

Данная проблема решается rollback'ом.
