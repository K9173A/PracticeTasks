## MRO
MRO (Member Resolution Order) - методика установления последовательности поиска методов класса при множественном
наследовании, помогающая избежать неоднозначности при вызове того или иного метода.

При множественном наследовании может возникнуть ситуация, когда в базовых классах имеется одноимённые функции. Для
разрешения данной ситуации используется **C3-линеаризация**, с помощью которой возможно выдать однозначный порядок
поиска методов.

### Варианты получения MRO
```python3
# Вариант 1
Derived.mro()
# Вариант 2
Derived.__mro__
```

### Пример
Пускай имеется ромбовидное наследование классов.
```python3
class Base:
    pass

class A(Base):
    def f(self):
        print('A')

class B(Base):
    def f(self):
        print('B')

class Derived(A, B):
    pass

Derived.mro()
```
Результат выполнения кода:
```python3
[
	# Самый высший приоритет у текущего класса (это логично!)
	"<class '__main__.Derived'>",
	# Следующий класс - родительский. Тот который стоит самым левым в списке!
	"<class '__main__.A'>",
	# Далее идёт следующий класс, читая, слева направо
	"<class '__main__.B'>",
	# Базовый класс в иерархии
	"<class '__main__.Base'>",
	# От данного класса неявно наследуются все классы
	"<class 'object'>"
]
```
В соответствии с MRO можно предсказать, что будет вызван метод из класса `A`.
```python3
d = Derived()
d.f() # 'A'
```
Для проверки можно провести линеаризацию вручную:
* `L(Class)` - линеаризация класса `Class`.
* `[A,B,C]` - список из трех элементов, где голова это `A`, а хвост `[B,C]`.
* `merge` - соединение (конкатенация) списков: `merge([1], [2,3]) = [1,2,3]`. 

Находим линеаризации родителей `Derived`: `L(A)`, `L(B)` и соединим их со списком из родителей `[A, B]`:
```
L(Derived) := Derived + merge(L(A), L(B), [A, B])
```
Класс `A` подходит для первого шага `merge`, потому что он появляется в начале всех списков:
```
L(Derived) := Derived + merge([A, Base], [B, Base], [A, B])
```

Класс `B` подходит для следующего шага `merge`, так как он не содержится в конце второго списка (все остальные списки
состоят из одного элемента - там и так всё понятно):
```
L(Derived) := [Derived, A] + merge([Base], [B, Base], [B])
```
Остаётся только базовый класс `Base`:
```
L(Derived) := [Derived, A, B] + merge([Base], [Base])
```
Результат:
```
L(Derived) := [Derived, A, B, Base]
```
Так как все классы наследуются от `object`, то итоговый список будет: `[Derived, A, B, Base, object]`.