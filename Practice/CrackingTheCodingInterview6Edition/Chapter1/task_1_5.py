"""
Реализуйте метод, осуществляющий сжатие строки, на основе счётчика
повторяющихся символов. Например, строка "aabcccccaaa" должна превратиться в
"a2b1c5a3". Если сжатая строка оказывается длиннее исходной, метод должен
вернуть исходную строку.
"""
import sys


def compress_string(string):
    """
    Сжимает строку на основе счётчика повторяющихся символов.
    :param string: исходная строка.
    :return: сжатая строка - если она короче исходной строки, в ином случае
    возвращает исходную строку.
    """
    compressed_string = ''
    repeated_char_counter = 0
    previous_char = None

    for index, char in enumerate(string):
        # Самый первый символ.
        if index == 0:
            # previous_char пока что None. Соответствено сравнивать нечего.
            repeated_char_counter += 1
        # Основная часть строки.
        elif 0 < index < len(string) - 1:
            # Если символы совпадают, то увеличиваем счётчик символов.
            if previous_char == char:
                repeated_char_counter += 1
            # Если символы отличаются - началась новая последовательность
            # символов, значит нужно записать предыдущую последовательность
            # и сбросить счётчик на 1 - текущий символ уже считается.
            else:
                compressed_string += f'{previous_char}{repeated_char_counter}'
                repeated_char_counter = 1
        # Самый последний символ строки.
        else:
            # Если символы совпадают, то текущий символ является продолжением
            # последовательности, соответственно просто записываем её. Но перед
            # этим увеличиваем на +1 счётчик, так как нужно посчитать текущий
            # символ.
            if previous_char == char:
                compressed_string += f'{previous_char}{repeated_char_counter + 1}'
            # Есди символы отличаются, то значит последний символ - это новая
            # последовательность. Значит нужно записать предыдущую последова-
            # тельность. А затем записать текущий символ - как отдельную пос-
            # ледовательность. Последний символ уже явно записываем, без
            # счётчика.
            else:
                compressed_string += f'{previous_char}{repeated_char_counter}'
                compressed_string += f'{char}1'
        # Перезапись симвла - на следующей итерации текущий символ будет
        # использован как предыдущий.
        previous_char = char
    # Если после компресси строка получилась длиннее исходной, то возвращаем
    # исходную строку.
    if len(compressed_string) > len(string):
        return string
    return compressed_string


if __name__ == '__main__':
    print(compress_string(sys.argv[1]))
