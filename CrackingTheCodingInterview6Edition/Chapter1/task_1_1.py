"""
Реализуйте алгоритм, определяющий, все ли символы в строке встречаются один
раз. При выполнении этого задания нельзя использовать дополнительные струк-
туры данных.
"""
import sys


def consists_of_unique_chars(string):
    """
    Определяет, все ли символы в строке встречаются один раз.
    :param string: исходная строка.
    :return: возвращает True, если все символы уникальны, в ином случае False.
    """
    # Так как по заданию не сказано, какая именно будет строка, принимаем,
    # что строка будет неотсортированной. Соответственно реализуем алгоритм
    # быстрой сортировки, чтобы все символы располагались по возрастанию.
    sorted_string = ''.join(quick_sort(list(string)))

    # Второй вариант
    # sorted_string = sorted(string)

    # Так как по заданию сказано, что нельзя использовать дополнительные
    # структуры, то словари не используем. Итерируемся по каждому символу
    # и сравниваем с предыдущим. В отсортированном массиве одинаковые сим-
    # волы будут расположены рядом, поэтому условие previous_char == char
    # в таком случае даст положительный результат.
    previous_char = None
    for char in sorted_string:
        if previous_char == char:
            return False
        previous_char = char
    return True


def quick_sort(array):
    """
    Рекурсивная реализация быстрой сортировки.
    :param array: массив с символами, которые можно сравнить.
    :return: отсортированный по возрастанию массив.
    """
    # Если пользователь передал на вход пустой массив или массив из 1 элемента,
    # то сортировка не целесообразна и можно просто вернуть исходный массив.
    if len(array) > 1:
        # В качестве элемента, с которым будут сравниваться все остальные эле-
        # менты, можно взять любой элемент в массиве. Я взял первый элемент.
        pivot = array[0]
        # Создаём пустые массивы, каждый для своего случая:
        # left: для символов, которые меньше pivot;
        # equal: для символов, которые равны pivot;
        # right: для символов, которые больше pivot;
        left, equal, right = [], [], []
        for item in array:
            if item > pivot:
                right.append(item)
            elif item == pivot:
                equal.append(item)
            elif item < pivot:
                left.append(item)
            else:
                raise ValueError('Comparison Error!')
        # Конкатенируем данные, которые вернутся из рекурсивных функций. Они
        # уже будут отсортированы.
        return quick_sort(left) + equal + quick_sort(right)
    return array


if __name__ == '__main__':
    print(consists_of_unique_chars(sys.argv[1]))
